#ifndef __PARAMS_H__
#define __PARAMS_H__

#include "real.H"
#include "error.H"
#include "clawpack_mempool.H"
#include "clawpack_device.H"

#include <stdio.h>
#include <string>
#include <cstring>

// using namespace std;

class pdeParam
{
    public:
        int cellsX;			// number of cells on the horizontal, including ghost cells (unpadded)
        int cellsY;			// number of cells on the vertical, including ghost cells
        const int numGhostCells;	// ghost cells for the boundaries
        const int numStates;	// number of states of the problem, number of scalars per cell
        const int numWaves;		// number of nonzero waves generated by the Riemann solver (usually as many as there are equations)
        const int numCoeff;		// number of different types medium properties

        bool second_order;		// second order accuracy computation flag

        real width;		       	// physical domain's width
        real height;       		// physical domain's height;
        real dx;		       	// physical domain's spacial discritization size on the horizontal
        real dy;		       	// physical domain's spacial discritization size on the vertical
        const real startX;		// physical domain's starting x in cartesian coordinates
        const real endX;		// physical domain's ending x in cartesian coordinates
        const real startY;		// physical domain's starting y in cartesian coordinates
        const real endY;		// physical domain's ending y in cartesian coordinates

        // real desired_CFL;		// a CFL number which determines the next time step length (dt)
        // real CFL_lower_bound;	// lower bound on the CFL to be used

        real dt;			// time step to be used in the computation

        real* coefficients;		// physical medium coefficients

        // GPU residents
        real* q;			// data, cells' states
        real* qNew;		       	// intermediate update holder

        // real* wavesX;		// horizontal waves
        // real* wavesY;		// vertical waves

        // Each entry in waveSpeedsX stores maximum u-velocity in one CUDA block. So the size
        // of waveSpeedsX should be number of CUDA blocks for this AMR grid patch
        // The same rule applies to waveSpeedsY
        // after calling reduceMax_simplified, waveSpeedsX[0] has the maximum u velocity on this grid, and
        // waveSpeedsY[0] has the maximum v velocity on this grid.
        real* waveSpeedsX;		// speed of horizontal waves
        real* waveSpeedsY;		// speed of vertical waves

        real* cfl_grid; // an array of size 1xSPACEDIM, storing cfl number in current grid patch in all directions

        const int dev_id; // ID of the device on which storage are allocated
        const int * const id_ptr; // address of local id of this grid

        pdeParam(int cellsX, int cellsY, int numGhostCells, int numStates, int numWaves, int numCoeff,
                real startX, real endX, real startY, real endY,
                real dt_,
                real* q_, real* qNew_, 
                real* waveSpeedsX_, real* waveSpeedsY_,
                real* coefficients_,
                real* cfl_grid_, const int * const id_ptr_, int dev_id_):
                cellsX(cellsX), cellsY(cellsY), numGhostCells(numGhostCells), numStates(numStates), numWaves(numWaves), numCoeff(numCoeff),
                startX(startX), endX(endX), startY(startY), endY(endY), dt(dt_),
                q(q_), qNew(qNew_), waveSpeedsX(waveSpeedsX_), waveSpeedsY(waveSpeedsY_),
                coefficients(coefficients_), cfl_grid(cfl_grid_), id_ptr(id_ptr_), dev_id(dev_id_)
        {

            width = endX-startX;
            height = endY-startY;
            dx = width/cellsX;
            dy = height/cellsY;

            second_order = true;

            // desired_CFL = 0.90f;
            // dt = 0.001;

        }

        // copy constructor
        pdeParam (const pdeParam&) = default;

        // assignment constructor
        pdeParam& operator=(const pdeParam& other) = delete;

        ~pdeParam() {}

        void setOrderOfAccuracy(int order)
        {
            if(order == 2)
                second_order = true;
            else
                second_order = false;
        }

        //    void setDesiredCFL(real desired_CFL)
        //	{
        //	    this->desired_CFL = desired_CFL;
        //	}
        //
        // void setLowerBoundCFL(real lower_bound_CFL)
        // {
        //     CFL_lower_bound = lower_bound_CFL;
        // }


        // GETTER AND SETTER FUNCTIONS

        // Q
        // Dictates how the memory layout for q will be
        __device__ __host__ 
        inline int getIndex_q(int row, int column, int state)
        {
            // Usual C/C++ row major order
            // state is the slowest moving dimension now, then row, then column
            return (state*cellsX*cellsY + row*cellsX + column);
        }
        inline __device__ real &getElement_q(int row, int column, int state)
        {
            return q[getIndex_q(row, column, state)];
        }
        inline __device__ void setElement_q(int row, int column, int state, real setValue)
        {
            q[getIndex_q(row, column, state)] = setValue;
        }

        // QNEW
        // Dictates how the memory layout for qNew will be
        inline __device__ int getIndex_qNew(int row, int column, int state)
        {
            // Usual C/C++ row major order
            // state is the slowest moving dimension now, then row, then column
            return (state*cellsX*cellsY + row*cellsX + column);
        }
        inline __device__ real &getElement_qNew(int row, int column, int state)
        {
            return qNew[getIndex_qNew(row, column, state)];
        }
        inline __device__ void setElement_qNew(int row, int column, int state, real setValue)
        {
            qNew[getIndex_qNew(row, column, state)] = setValue;
        }


        // COEFFICIENTS
        inline __device__ __host__ int getIndex_coeff(int row, int column, int coeff)
        {
            // Usual C/C++ row major order
            // coeff is the slowest moving dimension now, then row, then column
            return (coeff*cellsX*cellsY + row*cellsX + column);
        }

        inline __device__ real &getElement_coeff(int row, int column, int coeff)
        {
            return coefficients[getIndex_coeff(row, column, coeff)];
        }

        inline __device__ void setElement_coeff(int row, int column, int coeff, real setValue)
        {
            coefficients[getIndex_coeff(row, column, coeff)] = setValue;
        }

        inline void alloc_waveSpeedsX(size_t sz) {
            waveSpeedsX = (real*) clawpack_mempool_alloc_gpu_hold(sz, this->dev_id, *(this->id_ptr));
        }

        inline void alloc_waveSpeedsY(size_t sz) {
            waveSpeedsY = (real*) clawpack_mempool_alloc_gpu_hold(sz, this->dev_id, *(this->id_ptr));
        }


        inline void free_waveSpeedsX() {
            clawpack_mempool_free_gpu(this->waveSpeedsX, this->dev_id);
        }

        inline void free_waveSpeedsY() {
            clawpack_mempool_free_gpu(this->waveSpeedsY, this->dev_id);
        }

        // add cuda callback function to free memory allocated and managed by this pdeParam object
        // The memory will be free after all CUDA events in the stream before this function call are finished
        inline void register_allocated_memory() {
            // printf("register tag: %d.\n",*(this->id_ptr));
            cudaStream_t stream;
            get_cuda_stream(*(this->id_ptr), this->dev_id, &stream);
            cudaStreamAddCallback(stream, cudaCallback_release_gpu, (void*) this->id_ptr, 0);
        }

};

#endif
