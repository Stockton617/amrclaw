#ifndef __PARAMS_H__
#define __PARAMS_H__

#include "real.H"
#include <stdio.h>
#include "error.H"

#include <string>
#include <cstring>

// using namespace std;

class pdeParam
{
    public:
        int cellsX;			// number of cells on the horizontal, including ghost cells (unpadded)
        int cellsY;			// number of cells on the vertical, including ghost cells
        const int ghostCells;	// ghost cells for the boundaries
        const int numStates;	// number of states of the problem, number of scalars per cell
        const int numWaves;		// number of nonzero waves generated by the Riemann solver (usually as many as there are equations)
        const int numCoeff;		// number of different types medium properties

        bool second_order;		// second order accuracy computation flag

        real width;		       	// physical domain's width
        real height;       		// physical domain's height;
        real dx;		       	// physical domain's spacial discritization size on the horizontal
        real dy;		       	// physical domain's spacial discritization size on the vertical
        const real startX;		// physical domain's starting x in cartesian coordinates
        const real endX;		// physical domain's ending x in cartesian coordinates
        const real startY;		// physical domain's starting y in cartesian coordinates
        const real endY;		// physical domain's ending y in cartesian coordinates

        real desired_CFL;		// a CFL number which determines the next time step length (dt)
        // real CFL_lower_bound;	// lower bound on the CFL to be used

        real dt;			// time step to be used in the computation

        real* coefficients;		// physical medium coefficients

        // GPU residents
        real* q;			// data, cells' states
        real* qNew;		       	// intermediate update holder

        real* wavesX;		// horizontal waves
        real* wavesY;		// vertical waves

        // after calling reduceMax_simplified, waveSpeedsX[0] has the maximum u velocity on this grid, and
        // waveSpeedsY[0] has the maximum v velocity on this grid.
        real* waveSpeedsX;		// speed of horizontal waves
        real* waveSpeedsY;		// speed of vertical waves

        pdeParam(int cellsX, int cellsY, int ghostCells, int numStates, int numWaves, int numCoeff,
                real startX, real endX, real startY, real endY,
                real* q_, real* qNew_, 
                real* wavesX_, real* wavesY_, real* waveSpeedsX_, real* waveSpeedsY_,
                real* coefficients_):
                cellsX(cellsX), cellsY(cellsY), ghostCells(ghostCells), numStates(numStates), numWaves(numWaves), numCoeff(numCoeff),
                startX(startX), endX(endX), startY(startY), endY(endY),
                q(q_), qNew(qNew_), wavesX(wavesX_), wavesY(wavesY_), waveSpeedsX(waveSpeedsX_), waveSpeedsY(waveSpeedsY_),
                coefficients(coefficients_)
        {

            width = endX-startX;
            height = endY-startY;
            dx = width/cellsX;
            dy = height/cellsY;

            second_order = true;

            desired_CFL = 0.90f;
            dt = 0.001;

        }

        void setOrderOfAccuracy(int order)
        {
            if(order == 2)
                second_order = true;
            else
                second_order = false;
        }

        //    void setDesiredCFL(real desired_CFL)
        //	{
        //	    this->desired_CFL = desired_CFL;
        //	}
        //
        // void setLowerBoundCFL(real lower_bound_CFL)
        // {
        //     CFL_lower_bound = lower_bound_CFL;
        // }


        // GETTER AND SETTER FUNCTIONS

        // Q
        // Dictates how the memory layout for q will be
        __device__ __host__ 
        inline int getIndex_q(int row, int column, int state)
        {
            // Usual C/C++ row major order
            // state is the slowest moving dimension now, then row, then column
            return (state*cellsX*cellsY + row*cellsX + column);
        }
        inline __device__ real &getElement_q(int row, int column, int state)
        {
            return q[getIndex_q(row, column, state)];
        }
        inline __device__ void setElement_q(int row, int column, int state, real setValue)
        {
            q[getIndex_q(row, column, state)] = setValue;
        }

        // QNEW
        // Dictates how the memory layout for qNew will be
        inline __device__ int getIndex_qNew(int row, int column, int state)
        {
            // Usual C/C++ row major order
            // state is the slowest moving dimension now, then row, then column
            return (state*cellsX*cellsY + row*cellsX + column);
        }
        inline __device__ real &getElement_qNew(int row, int column, int state)
        {
            return qNew[getIndex_qNew(row, column, state)];
        }
        inline __device__ void setElement_qNew(int row, int column, int state, real setValue)
        {
            qNew[getIndex_qNew(row, column, state)] = setValue;
        }


        // COEFFICIENTS
        inline __device__ __host__ int getIndex_coeff(int row, int column, int coeff)
        {
            // Usual C/C++ row major order
            // coeff is the slowest moving dimension now, then row, then column
            return (coeff*cellsX*cellsY + row*cellsX + column);
        }

        inline __device__ real &getElement_coeff(int row, int column, int coeff)
        {
            return coefficients[getIndex_coeff(row, column, coeff)];
        }

        inline __device__ void setElement_coeff(int row, int column, int coeff, real setValue)
        {
            coefficients[getIndex_coeff(row, column, coeff)] = setValue;
        }

};

#endif
