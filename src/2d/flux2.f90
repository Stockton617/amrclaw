!> Solve Riemann problems based on 1D slice of the 2D grid.
!! Return fluxes contributed by this slice.
!!
!! If **ixy** = 1, it's a slice in x. 
!! If **ixy** = 2, it's a slice in y. 
!!
!! Suppose it's a slice in x, the subroutine call normal Riemann 
!! solver to get fluctuations at edges(i-1/2,j)
!! and store the fluctuations in flux form: **faddm**, **faddp**.
!! It also call transverse Riemann soler to get up-goning and down-going
!! transverse waves and store them in **gaddm** and **gaddp**.
!!
!! **gaddm** is value to be added to gm, which is g flux on the lower side
!! of a cell edge. 
!! **gaddp** is value to be added to gp, which is g flux on the upper side
!! of a cell edge. 
!! Here **gaddm** and **gaddp** have the same value since g flux
!! on upper side and lower side of a cell edge should be the same (it's not 
!! like apdq and amdq at the edge).
!! **gaddm(*,i,.,1)** or **gaddp(*,i,.,1)** modifies G below cell i;
!! **gaddm(*,i,.,2)** or **gaddp(*,i,.,2)** modifies G above cell i;
!     =====================================================
subroutine flux2(ixy,maxm,meqn,maux,mbc,mx, &
        q1d,dtdx1d,aux1,aux2,aux3, &
        faddm,faddp,gaddm,gaddp,cfl1d,wave,s, &
        amdq,apdq,cqxx,bmasdq,bpasdq,rpn2,rpt2)
!     =====================================================
!
!     # clawpack routine ...  modified for AMRCLAW
!
!     # Compute the modification to fluxes f and g that are generated by
!     # all interfaces along a 1D slice of the 2D grid. 
!     #    ixy = 1  if it is a slice in x
!     #          2  if it is a slice in y
!     # This value is passed into the Riemann solvers. The flux modifications
!     # go into the arrays fadd and gadd.  The notation is written assuming
!     # we are solving along a 1D slice in the x-direction.
!
!     # fadd(*,i,.) modifies F to the left of cell i
!     # gadd(*,i,.,1) modifies G below cell i
!     # gadd(*,i,.,2) modifies G above cell i
!
!     # The method used is specified by method(2:3):
!
!         method(2) = 1 if only first order increment waves are to be used.
!                   = 2 if second order correction terms are to be added, with
!                       a flux limiter as specified by mthlim.  
!
!         method(3) = 0 if no transverse propagation is to be applied.
!                       Increment and perhaps correction waves are propagated
!                       normal to the interface.
!                   = 1 if transverse propagation of increment waves 
!                       (but not correction waves, if any) is to be applied.
!                   = 2 if transverse propagation of correction waves is also
!                       to be included.  
!
!     Note that if mcapa>0 then the capa array comes into the second 
!     order correction terms, and is already included in dtdx1d:
!     If ixy = 1 then
!        dtdx1d(i) = dt/dx                      if mcapa= 0
!                  = dt/(dx*aux(mcapa,i,jcom))  if mcapa = 1
!     If ixy = 2 then
!        dtdx1d(j) = dt/dy                      if mcapa = 0
!                  = dt/(dy*aux(mcapa,icom,j))  if mcapa = 1
!
!     Notation:
!        The jump in q (q1d(i,:)-q1d(i-1,:))  is split by rpn2 into
!            amdq =  the left-going flux difference  A^- Delta q  
!            apdq = the right-going flux difference  A^+ Delta q  
!        Each of these is split by rpt2 into 
!            bmasdq = the down-going transverse flux difference B^- A^* Delta q
!            bpasdq =   the up-going transverse flux difference B^+ A^* Delta q
!        where A^* represents either A^- or A^+.
!
!
    use amr_module
    use parallel_advanc_module, only: icom, jcom

    implicit real(CLAW_REAL) (a-h,o-z)
    external rpn2, rpt2, rpn2_no_aux
    dimension    q1d(meqn,1-mbc:maxm+mbc)
    dimension   amdq(meqn,1-mbc:maxm+mbc)
    dimension   apdq(meqn,1-mbc:maxm+mbc)
    dimension bmasdq(meqn,1-mbc:maxm+mbc)
    dimension bpasdq(meqn,1-mbc:maxm+mbc)
    dimension   cqxx(meqn,1-mbc:maxm+mbc)
    dimension   faddm(meqn,1-mbc:maxm+mbc)
    dimension   faddp(meqn,1-mbc:maxm+mbc)
    dimension   gaddm(meqn,1-mbc:maxm+mbc, 2)
    dimension   gaddp(meqn,1-mbc:maxm+mbc, 2)
    dimension dtdx1d(1-mbc:maxm+mbc)
    dimension aux1(maux,1-mbc:maxm+mbc)
    dimension aux2(maux,1-mbc:maxm+mbc)
    dimension aux3(maux,1-mbc:maxm+mbc)
    !
    dimension     s(mwaves, 1-mbc:maxm+mbc)
    dimension  wave(meqn, mwaves, 1-mbc:maxm+mbc)
    !
    logical limit
    ! common /comxyt/ dtcom,dxcom,dycom,tcom,icom,jcom
    !
    limit = .false.
    do mw=1,mwaves
        if (mthlim(mw) .gt. 0) limit = .true.
    enddo
    !
    !     # initialize flux increments:
    !     -----------------------------
    !
    do i = 1-mbc, mx+mbc
        do m=1,meqn
            faddm(m,i) = 0.d0
            faddp(m,i) = 0.d0
            gaddm(m,i,1) = 0.d0
            gaddp(m,i,1) = 0.d0
            gaddm(m,i,2) = 0.d0
            gaddp(m,i,2) = 0.d0
        enddo
    enddo

    !
    !
    !     # solve Riemann problem at each interface and compute Godunov updates
    !     ---------------------------------------------------------------------
    !

    call rpn2(ixy,maxm,meqn,mwaves,maux,mbc,mx,q1d,q1d, &
        aux2,aux2,wave,s,amdq,apdq)



    !
    !     # Set fadd for the donor-cell upwind method (Godunov)
    do i=1,mx+1
        do m=1,meqn
            faddp(m,i) = faddp(m,i) - apdq(m,i)
            faddm(m,i) = faddm(m,i) + amdq(m,i)
        enddo
    enddo
    !
    !     # compute maximum wave speed for checking Courant number:
    cfl1d = 0.d0
    do mw=1,mwaves
        do i=1,mx+1
            !          # if s>0 use dtdx1d(i) to compute CFL,
            !          # if s<0 use dtdx1d(i-1) to compute CFL:
            cfl1d = max(cfl1d, dtdx1d(i)*s(mw,i),-dtdx1d(i-1)*s(mw,i))
        enddo
    enddo
    !
    if (method(2).ne.1) then
        !
        !     # modify F fluxes for second order q_{xx} correction terms:
        !     -----------------------------------------------------------
        !
        !     # apply limiter to waves:
        if (limit) call limiter(maxm,meqn,mwaves,mbc,mx,wave,s,mthlim)


        do i = 1, mx+1
            !
            !        # For correction terms below, need average of dtdx in cell
            !        # i-1 and i.  Compute these and overwrite dtdx1d:
            !
            !        # modified in Version 4.3 to use average only in cqxx, not transverse
            dtdxave = 0.5d0 * (dtdx1d(i-1) + dtdx1d(i))

            !
            !        # second order corrections:

            do m=1,meqn
                cqxx(m,i) = 0.d0
                do mw=1,mwaves
                    !
                    if (use_fwaves) then
                        abs_sign = sign(1.d0,s(mw,i))
                    else
                        abs_sign = dabs(s(mw,i))
                    endif

                    cqxx(m,i) = cqxx(m,i) + abs_sign * &
                        (1.d0 - dabs(s(mw,i))*dtdxave) * wave(m,mw,i)
                    !
                enddo
                faddm(m,i) = faddm(m,i) + 0.5d0 * cqxx(m,i)
                faddp(m,i) = faddp(m,i) + 0.5d0 * cqxx(m,i)
            enddo
        enddo

    endif

    !
    if (method(3).ne.0) then !# has transverse propagation
        if (method(2).gt.1 .and. method(3).eq.2) then
            !         # incorporate cqxx into amdq and apdq so that it is split also.
            do i = 1, mx+1
                do m=1,meqn
                    amdq(m,i) = amdq(m,i) + cqxx(m,i)
                    apdq(m,i) = apdq(m,i) - cqxx(m,i)
                enddo
            enddo
        endif
        !
        !
        !      # modify G fluxes for transverse propagation
        !      --------------------------------------------
        !
        !
        !     # split the left-going flux difference into down-going and up-going:
        call rpt2(ixy,1,maxm,meqn,mwaves,maux,mbc,mx, &
            q1d,q1d,aux1,aux2,aux3, &
            amdq,bmasdq,bpasdq)
        !
        !     # modify flux below and above by B^- A^- Delta q and  B^+ A^- Delta q:
        do i = 1, mx+1
            do m=1,meqn
                gupdate = 0.5d0*dtdx1d(i-1) * bmasdq(m,i)
                gaddm(m,i-1,1) = gaddm(m,i-1,1) - gupdate
                gaddp(m,i-1,1) = gaddp(m,i-1,1) - gupdate
                !
                gupdate = 0.5d0*dtdx1d(i-1) * bpasdq(m,i)
                gaddm(m,i-1,2) = gaddm(m,i-1,2) - gupdate
                gaddp(m,i-1,2) = gaddp(m,i-1,2) - gupdate
            enddo
        enddo
        !
        !     # split the right-going flux difference into down-going and up-going:
        call rpt2(ixy,2,maxm,meqn,mwaves,maux,mbc,mx, &
            q1d,q1d,aux1,aux2,aux3, &
            apdq,bmasdq,bpasdq)
        !
        !     # modify flux below and above by B^- A^+ Delta q and  B^+ A^+ Delta q:
        do i = 1, mx+1
            do m=1,meqn
                gupdate = 0.5d0*dtdx1d(i) * bmasdq(m,i)
                gaddm(m,i,1) = gaddm(m,i,1) - gupdate
                gaddp(m,i,1) = gaddp(m,i,1) - gupdate
                !
                gupdate = 0.5d0*dtdx1d(i) * bpasdq(m,i)
                gaddm(m,i,2) = gaddm(m,i,2) - gupdate
                gaddp(m,i,2) = gaddp(m,i,2) - gupdate
            enddo
        enddo
    endif

    return
end subroutine flux2
